December 2, 2021 Arrays / Binary search / Data Structure
Median of Two Sorted Arrays of different sizes
Problem Statement: Given two sorted arrays arr1 and arr2 of size m and n respectively, return the median of the two sorted arrays. The median is defined as the middle value of a sorted list of numbers. In case the length of the list is even, the median is the average of the two middle elements.


Examples
Example 1:
Input Format: n1 = 3, arr1[] = {2,4,6}, n2 = 3, arr2[] = {1,3,5}
Result: 3.5
Explanation: The array after merging 'a' and 'b' will be { 1, 2, 3, 4, 5, 6 }. As the length of the merged list is even, the median is the average of the two middle elements. Here two medians are 3 and 4. So the median will be the average of 3 and 4, which is 3.5.

Example 2:
Input Format: n1 = 3, arr1[] = {2,4,6}, n2 = 2, arr2[] = {1,3}
Result: 3
Explanation: The array after merging 'a' and 'b' will be { 1, 2, 3, 4, 6 }. The median is simply 3.


Optimal Approach
Algorithm / Intuition
We are going to use the Binary Search algorithm to optimize the approach.

The primary objective of the Binary Search algorithm is to efficiently determine the appropriate half to eliminate, thereby reducing the search space by half. It does this by determining a specific condition that ensures that the target is not present in that half.

Now, letâ€™s learn through the following observations how we can apply binary search to this problem. First, we will try to solve this problem where n1+n2 is even and then we will consider the odd scenario.

double median(vector<int>& a, vector<int>& b) {
	int n1 = a.size();
	int n2 = b.size();
	if(n1>n2) return median(b, a);
	int low = 0;
	int high = n1;
	int left = (n1+n2+1)/2;
	int n = n1+n2;
	while(low<=high)
	{
		int mid1 = (low+high)/2;
		int mid2 = left-mid1;
		int l1 = INT_MIN, l2=INT_MIN;
		int r1 = INT_MAX, r2=INT_MAX;
		if(mid1<n1) r1=a[mid1];
		if(mid2<n2) r2=b[mid2];
		if(mid1-1>=0) l1=a[mid1-1];
		if(mid2-1>=0) l2=b[mid2-1];

		if(l1<=r2 && l2<=r1){
			if(n%2!=0){
				return max(l1,l2);
			}
			else return (double)(max(l1, l2) + min(r1, r2)) / 2.0;
		}
		else if (l1>r2) high=mid1-1;
		else low=mid1+1;
	}
	return 0;
}
Complexity Analysis
Time Complexity: O(log(min(n1,n2))), where n1 and n2 are the sizes of two given arrays.
Reason: We are applying binary search on the range [0, min(n1, n2)].

Space Complexity: O(1) as no extra space is used.

